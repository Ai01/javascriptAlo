# 二叉树

## 什么是二叉树

> 二叉树是一种子节点不超过两个的树

## 什么是二叉查找树

> 二叉查找树是二叉树的变种。要求左节点必须小于右节点。查找效率很高。

## 二叉树应该有哪些操作

1. 插入节点，(对于二叉树来说可能需要有额外的数据，为了解决这个问题，二叉树的节点上的数据应该有额外的数据，所以最好是一个 object)。(insert)
2. 遍历节点，前序遍历，后序遍历，中序遍历。
3. 获取最大最小值。getMax, getMin
4. 查找节点。find
5. 删除节点。remove
6. 获取根节点。getRootNode

## 代码实现细节

```js
class Node {
  constructor(data, left, right, extraData) {
    // 对二叉树的节点来说，可能需要有额外的数据。所以加上extraData这个函数
    // TODO: bai 如果将一个层级结构的数据在构造的时候变成tree。
    this.data = data;
    this.left = left || null;
    this.right = right || null;
  }
}

class BinarySearchTree {
  // 在插入数据的时候需要从root节点来实现对整个树的遍历。来找到父级实现插入数据。
  // 需要注意的是找到父级，而不是改变当前的二叉树的结构，不会取代现有节点的位置
  // 找到父级的方法是在迭代中比较当前节点和data的大小，
  // 小于data，则将当前节点改为右节点
  // 大于data，则将当前节点改为左节点
  insert(data) {}
  
  // 前序，中序和后序的不同之处在于父节点出现的顺序。用递归实现
  // 为了使遍历是有价值的，需要接受node和回调函数cb作为参数。不同之处就在于cb执行的位置
  inOrderTraverse(){}
  preOrderTraverse(){}
  postOrderTraverse(){}
  
  // 因为查找二叉树的特殊性：小的在左节点，大的在右节点。所以在查找的时候的基本原则是：
  // 变量二叉树，如果当前节点的数据大于要查找的数据那么去左子树继续。否则去右子树
  find(data){}
  getMax(){}
  getMin(){}
  
  // remove的第一部是找到当前的数据。
  // 在找到数据后有不同的情况。
  // 1. 数据没有子树(那么直接将它赋值null)
  // 2. 数据有子树:
  // 如果只有左子树或者右子树那么用子树替代当前节点就可以了。
  // 如果左子树和右子树都有那么有两种处理方式：1. 找左子树中的最大值作为新的node。2.找右子树中的最小值作为新的node
  remove(data){}
  
}
```
