# 编辑距离

## 题目

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

```
输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```


## 方法

**从最小的例子入手。做一张表就可以很容易的看出规律**

假设

```
    1. 字符串 a, 共 m 位，从 a[1] 到 a[m]
    2. 字符串 b, 共 n 位，从 b[1] 到 b[n]
    3. d[i][j] 表示字符串 a[1]-a[i] 转换为 b[1]-b[j] 的编辑距离
```

那么有如下规律（a[i] 和 b[j] 分别是字符串 a 和 b 的最后一位）：

```
    1. 当 a[i] 等于 b[j] 时，d[i][j] = d[i-1][j-1], 比如 fxy -> fay 的编辑距离等于 fx -> fa 的编辑距离
    2. 当 a[i] 不等于 b[j] 时，d[i][j] 等于如下 3 项的最小值：
        d[i-1][j] + 1（删除 a[i]）， 比如 fxy -> fab 的编辑距离 = fx -> fab 的编辑距离 + 1
        d[i][j-1] + 1（插入 b[j])， 比如 fxy -> fab 的编辑距离 = fxy -> fa 的编辑距离 + 1
        d[i-1][j-1] + 1（将 a[i] 替换为 b[j]）， 比如 fxy -> fab 的编辑距离 = fx -> fa 的编辑距离 + 1
```
        
边界：

```
    1. a[i][0] = i, b 字符串为空，表示将 a[1]-a[i] 全部删除，所以编辑距离为 i
    2. a[0][j] = j, a 字符串为空，表示 a 插入 b[1]-b[j]，所以编辑距离为 j
```


### 方法1

#### 思路

递归

#### 复杂度

递归的复杂度计算还需要学习

### 方法2

#### 思路

递归的解决思路，是从后往前算的。而利用动态规划，可以从前往后算。避免递归算法中对相同结果的多次计算。 

步骤

    1. 首先建立一个矩阵，用来存放子问题及原问题的编辑距离，并将递归边界在矩阵中填好
    2. 然后计算 i = 1, j = 1 所对应的编辑距离：比较 a[i] 和 b[j] 是否相等然后根据递归规律算出这个值
       比如在这种情况下 a[i] = f 和 b[j] = f, 那么 d[i][j] 就等于 d[i-1][j-1] 等于 0
       然后计算 i = 1, j = 2 直到算出 i = 3, j = 3, 原问题的编辑距离就等于 d[3][3]
       最终矩阵如下 

#### 复杂度

时间复杂度: O(mn) 

空间复杂度: O(mn)

