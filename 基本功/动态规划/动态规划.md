# 动态规划

## 为什么要学习动态规划

1. 动态规划可以降低算法的复杂度

## 什么是动态规划

动态规划是一种算法思想

在面对当前问题的解可以由上一次子问题的解推出的情况时, 通常基于一个递推公式及一个或多个初始状态,从
最小的问题开始实现对最终问题的求解。


## 如何使用动态规划

### 实例

如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ 

首先我们思考一个问题，如何用最少的硬币凑够i元(i<11)？为什么要这么问呢？ 两个原因：

    1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 
    2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。
    
当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 

这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便，
如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。

于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。

当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。
所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。

当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 
接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 
所以d(2)=d(2-1)+1=d(1)+1=1+1=2。

让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的。 既然能用的硬币有两种，我就有两种方案。
如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。
即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；
第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。
即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。
记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？
具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1} 
  

> 从上面的例子中我们可以看出,**找到问题的递推公式(状态转移方程)。就找到了解决问题的方法。**


> 上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的**状态**， 这个状态是怎么找出来的呢？
根据子问题定义状态。你找到子问题，状态也就浮出水面了

> 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 
上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 
它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，
  
  d(i)=min{ d(i-vj)+1 }，其中i-vj >=0
  
> vj表示第j个硬币的面值。+1表示的是可以在d(i - vj)的基础上加上一个面值为v的硬币达到效果

### 实例总结

1. 遇到一个大问题时，将问题的规模变小
2. 抽象出问题的数学模型(用d(i)=j来表示凑够i元最少需要j个硬币)
3. 从最小的情况来推演，问题的演变，观察规模的变化是否对问题产生改变。也就是观察问题是否可以合适动态规划
4. 如果合适，找到问题的状态转移方程


## 挑战

1. "最长非降子序列的长度"问题


## 参考资料

1. http://www.hawstein.com/posts/dp-novice-to-advanced.html
